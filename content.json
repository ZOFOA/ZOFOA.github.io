{"meta":{"title":"ZOFOA","subtitle":"ZOFOA's Blog","description":"宁静致远. The quieter you become, the more you are able to hear.","author":"ZOFOA","url":"https://zofoa.github.io","root":"/"},"pages":[{"title":"关于","date":"2076-11-29T08:54:34.955Z","updated":"2020-08-02T11:47:06.000Z","comments":false,"path":"about/index.html","permalink":"https://zofoa.github.io/about/index.html","excerpt":"","text":"个人详细介绍如果事与愿违，请你在坚持坚持!我还是从前那个少年，没有一丝丝改变!"},{"title":"分类","date":"2020-04-24T05:27:19.000Z","updated":"2020-04-26T12:43:58.000Z","comments":false,"path":"categories/index.html","permalink":"https://zofoa.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-04-24T05:40:30.000Z","updated":"2020-04-26T12:35:58.000Z","comments":false,"path":"link/index.html","permalink":"https://zofoa.github.io/link/index.html","excerpt":"","text":"ssssssssss 111111111112"},{"title":"标签","date":"2020-04-24T05:23:29.000Z","updated":"2020-04-26T12:09:18.000Z","comments":false,"path":"tags/index.html","permalink":"https://zofoa.github.io/tags/index.html","excerpt":"","text":""},{"title":"音乐","date":"2020-04-24T05:23:29.000Z","updated":"2020-04-26T12:09:28.000Z","comments":false,"path":"music/index.html","permalink":"https://zofoa.github.io/music/index.html","excerpt":"","text":""}],"posts":[{"title":"Centos Linux 主机加固","slug":"Centos Linux 主机加固","date":"2021-04-22T07:00:10.000Z","updated":"2021-04-28T06:25:24.000Z","comments":true,"path":"2021/04/22/Centos Linux 主机加固/","link":"","permalink":"https://zofoa.github.io/2021/04/22/Centos%20Linux%20%E4%B8%BB%E6%9C%BA%E5%8A%A0%E5%9B%BA/","excerpt":"","text":"一、身份鉴别1、密码策略设置/etc/login.defs1234PASS_MAX_DAYS 90 #可以使用密码的最大天数PASS_MIN_DAYS 2 #两次密码更改之间允许的最短天数PASS_MIN_LEN 8 #可接受的最小密码长度PASS_WARN_AGE 7 #密码过期前给出的警告天数。 /etc/pam.d/system-auth12345678password requisite pam_pwquality.so try_first_pass local_users_only retry=3 authtok_type= minlen=8 lcredit=-1 ucredit=-1 dcredit=-1 ocredit=-1 enforce_for_rootminlen=8 密码最小长度为8个字符。lcredit=-1 密码应包含的小写字母的至少一个ucredit=-1 密码应包含的大写字母至少一个dcredit=-1 将密码包含的数字至少为一个ocredit=-1 设置其他符号的最小数量，例如@，＃、! $％等，至少要有一个enforce_for_root 确保即使是root用户设置密码，也应强制执行复杂性策略 2、登录失败处理pam_faillock PAM模块允许系统管理员锁定在指定次数内登录尝试失败的用户账户。限制用户登录尝试的次数主要是作为一个安全措施，旨在防止可能针对获取用户的账户密码的暴力破解 通过 pam_faillock模块，将登录尝试失败的数据储存在 /var/run/faillock 目录下每位用户的独立文件中 配置 添加以下命令行到 /etc/pam.d/system-auth文件和/etc/pam.d/password-auth文件中的对应区段： 1234auth required pam_faillock.so preauth silent audit deny&#x3D;3 unlock_time&#x3D;300auth sufficient pam_unix.so nullok try_first_passauth [default&#x3D;die] pam_faillock.so authfail audit deny&#x3D;3 unlock_time&#x3D;300account required pam_faillock.so 注意： auth required pam_faillock.so preauth silent audit deny=3 必须在最前面。 适用于root在pam_faillock 条目里添加 even_deny_root 选项 查看每个用户的尝试失败次数 1faillock 解锁一个用户的账户 1faillock --user root --reset 3、安装telnet检查是否安装有telnet，键入：rpm -qa | grep telnet 回车返回空值则说明没有安装，返回telnet版本号则说明已经安装； 检查是否安装有xinetd，键入：rpm -qa | grep xinetd 回车返回空值则说明没有安装，返回xinetd版本号则说明已经安装； yum -y install telnet* # 安装telnet客户端和服务端； yum -y install xinetd # 安装xinetd客户端和服务端； telnet服务安装之后，默认是不开启服务，修改文件/etc/xinetd.d/telnet来开启服务。如下图，在xinetd.d目下没有telnet文件，那么我们就需要使用 vim telnet 创建一个文件并写入以下内容保存即可，注意如果目录下存在telnet需要将 disable 修改为 disable = no 默认的disable = yes 12345678910111213# default: yes # description: The telnet server servestelnet sessions; it uses \\ # unencrypted username/password pairs for authentication. service telnet &#123; flags = REUSE socket_type = stream wait = no user = root server =/usr/sbin/in.telnetd log_on_failure += USERID disable = no &#125; 由于上面修改了telnet配置文件，需要重新启动下服务，看telnet、xinetd是否启动成功； 123systemctl restart xinetd.service # 重启xinetd服务；ps -ef | grep xinetd # 查看xinetd服务；ps -ef | grep telnet # 查看telnet服务； 将telnet和xinetd加入到开机启动服务； 12systemctl enable xinetd.service # 将xinetd加入到开机启动服务；systemctl enable telnet.socket #将telnet加入到开机启动服务； 防火墙开启23端口允许通过 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051firewall-cmd --query-port=23/tcp # 查询端口是否开放firewall-cmd --add-port=23/tcp --permanent #永久添加23端口例外(全局)firewall-cmd --add-port=23/udp --permanentfirewall-cmd --reload #重启防火墙(修改配置后要重启防火墙)PS:基础防火墙配置1、安装yum install iptables-services #安装iptables2、systemctl使用systemctl unmask firewalld #执行命令，即可实现取消服务的锁定systemctl mask firewalld # 下次需要锁定该服务时执行systemctl start firewalld.service #启动防火墙systemctl stop firewalld.service #停止防火墙systemctl reloadt firewalld.service #重载配置systemctl restart firewalld.service #重启服务systemctl status firewalld.service #显示服务的状态systemctl enable firewalld.service #在开机时启用服务systemctl disable firewalld.service #在开机时禁用服务systemctl is-enabled firewalld.service #查看服务是否开机启动systemctl list-unit-files|grep enabled #查看已启动的服务列表systemctl --failed #查看启动失败的服务列表3、firewall-cmd使用firewall-cmd --state #查看防火墙状态firewall-cmd --reload #更新防火墙规则firewall-cmd --state #查看防火墙状态firewall-cmd --reload #重载防火墙规则firewall-cmd --list-ports #查看所有打开的端口firewall-cmd --list-services #查看所有允许的服务firewall-cmd --get-services #获取所有支持的服务#区域相关firewall-cmd --list-all-zones #查看所有区域信息firewall-cmd --get-active-zones #查看活动区域信息firewall-cmd --set-default-zone=public #设置public为默认区域firewall-cmd --get-default-zone #查看默认区域信息firewall-cmd --zone=public --add-interface=eth0 #将接口eth0加入区域public#接口相关firewall-cmd --zone=public --remove-interface=eth0 #从区域public中删除接口eth0firewall-cmd --zone=default --change-interface=eth0 #修改接口eth0所属区域为defaultfirewall-cmd --get-zone-of-interface=eth0 #查看接口eth0所属区域4、用例firewall-cmd --query-port=8080/tcp # 查询端口是否开放firewall-cmd --add-port=80/tcp --permanent #永久添加80端口例外(全局)firewall-cmd --remove-port=80/tcp --permanent #永久删除80端口例外(全局)firewall-cmd --add-port=65001-65010/tcp --permanent #永久增加65001-65010例外(全局)firewall-cmd --zone=public --add-port=80/tcp --permanent #永久添加80端口例外(区域public)firewall-cmd --zone=public --remove-port=80/tcp --permanent #永久删除80端口例外(区域public)firewall-cmd --zone=public --add-port=65001-65010/tcp --permanent #永久增加65001-65010例外(区域public)firewall-cmd --reload #重启防火墙(修改配置后要重启防火墙) 4、Linux用户密码加密方式对于示例的密码域security:$6$/8I.5J/u70BOWYri$TfgBP0YJhGcFmZlKQQnetNVV.aaS7GGYefEaeFsvKHA/LbBWYMcxTMYMpJtCihFkaE/OKqgQF/bSJAUR4SvTk1:18739:0:99999:7:::，我们参考了linux标准源文件passwd.c，在其中的pw_encrypt函数中找到了加密方法。 我们发现所谓的加密算法，其实就是用明文密码和一个叫salt的东西通过函数crypt()完成加密。 而所谓的密码域密文也是由三部分组成的，即：$id$salt$encrypted。 【注】： id为1时，采用md5进行加密； id为5时，采用SHA256进行加密； id为6时，采用SHA512进行加密。","categories":[{"name":"等保2.0","slug":"等保2-0","permalink":"https://zofoa.github.io/categories/%E7%AD%89%E4%BF%9D2-0/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://zofoa.github.io/tags/Linux/"},{"name":"主机加固","slug":"主机加固","permalink":"https://zofoa.github.io/tags/%E4%B8%BB%E6%9C%BA%E5%8A%A0%E5%9B%BA/"}]},{"title":"华为交换机配置","slug":"华为交换机配置","date":"2021-04-20T07:00:10.000Z","updated":"2021-04-28T06:24:30.000Z","comments":true,"path":"2021/04/20/华为交换机配置/","link":"","permalink":"https://zofoa.github.io/2021/04/20/%E5%8D%8E%E4%B8%BA%E4%BA%A4%E6%8D%A2%E6%9C%BA%E9%85%8D%E7%BD%AE/","excerpt":"","text":"创建VLANsystem_viewvlan 10 或 vlan batch 10 to 13 给 VLAN配置ipinterface vlanif 10 ip address 192.168.10.1 24 配置端口组加入vlan 10port-group 1 #创建端口组 group-member GigabitEthernet 0/0/1 to GigabitEthernet 0/0/5 #选择1-5端口 port link-type access #接口为access口，显示1~6口设置为access类型 port default vlan 10 端口组所有端口加入vlan10 save 用户视图保存配置Quidway] display version 显示VRP版本号[Quidway] display current-configuration 显示系统运行配置信息[Quidway] display saved-configuration 显示保存的配置信息[Quidway] display interfaces brief 显示接口配置信息[Quidway]display ip routing-table 显示路由表user-interface maximum-vty 15 配置VTY用户界面的最大个数（同时可以登录的最大数）telnet server enable 开启telnetundo interface Vlanif 2 //删除Vlan 接口undo vlan 2 //删除创建的vlan 创建用户user-interface maximum-vty 15 配置VTY用户界面的最大个数（同时可以登录的最大数）user-interface vty 0 4 进入虚拟终端authentication-mode aaa 设置认证模式为AAA配置视图 aaalocal-user admin password cipher 123456 创建用户admin 123456 local-user admin privilege level 3 设置授权访问级别local-user admin service-type telnet 授权使用的服务user-interface con 0 进入console authentication-mode aaa 设置认证模式为AAA#创建acl策略acl name kongzhi 2001rule 5 permit source 192.168.13.0 0.0.0.255rule 10 deny #在vty接口应用acl 2001user-interface vty 0 4acl 2001 inbound","categories":[{"name":"等保2.0","slug":"等保2-0","permalink":"https://zofoa.github.io/categories/%E7%AD%89%E4%BF%9D2-0/"}],"tags":[{"name":"网络","slug":"网络","permalink":"https://zofoa.github.io/tags/%E7%BD%91%E7%BB%9C/"}]},{"title":"安卓APP证书签名验证","slug":"安卓app证书签名验证","date":"2021-04-20T02:46:19.000Z","updated":"2021-04-28T06:24:56.000Z","comments":true,"path":"2021/04/20/安卓app证书签名验证/","link":"","permalink":"https://zofoa.github.io/2021/04/20/%E5%AE%89%E5%8D%93app%E8%AF%81%E4%B9%A6%E7%AD%BE%E5%90%8D%E9%AA%8C%E8%AF%81/","excerpt":"","text":"安卓APP证书签名验证一、签名验证方法一(keytool,只支持V1签名校验)123keytool -printcert -jarfile C:\\Users\\zhfe\\Desktop\\b953d9cfc2d9b0f423eee2354ae0c9e1.apkkeytool -printcert -jarfile MyApp.apk (显示签名证书信息) 参数: ​ -printcert 打印证书内容​ -jarfile 已签名的jar文件 或apk文件 这是一个X.509 v3证书。包含如下内容： owner所有者：公钥持有者 issuer颁发者：为公钥提供保证的人 serial number序列号：证书唯一标识 valid from … until有效期：证书有效期，作为证书有效性验证 certification fingerprints证书指纹：证书数字校验和，验证是否被篡改 其中与app相关的签名是 cert.sf 文件，可以使用 cat 命令查看 两个文件都列出了各个资源文件的hash值，并经过了base64编码 三个文件的具体内容以及作用： ​ 解压apk，META-INF包含.MF、.RSA、.SF三个文件 manifest.mf: 声明资源 cert.rsa: 公钥证书 cert.sf: 包含app所有资源，负责对app签名，包含jar指定的密码学意义上的签名 方法二(apksigner,支持V1和V2签名校验) 进入Android SDK/build-tools/SDK版本, 输入命令 1apksigner verify -v --print-certs xxx.apk 参数: ​ -v, –verbose 显示详情(显示是否使用V1和V2签名)​ –print-certs 显示签名证书信息 例如: 1apksigner verify -v MyApp.apk ​ Verifies​ Verified using v1 scheme (JAR signing): true​ Verified using v2 scheme (APK Signature Scheme v2): true​ Number of signers: 1 二、工具介绍jarsigner是JDK提供的针对jar包签名的通用工具, 位于JDK/bin/jarsigner.exe apksigner是Google官方提供的针对Android apk签名及验证的专用工具, 位于Android SDK/build-tools/SDK版本/apksigner.bat 不管是apk包,还是jar包,本质都是zip格式的压缩包,所以它们的签名过程都差不多(仅限V1签名), 以上两个工具都可以对Android apk包进行签名. 1.V1和V2签名的区别在Android Studio中点击菜单 Build-&gt;Generate signed apk… 打包签名过程中, 可以看到两种签名选项 V1(Jar Signature) V2(Full APK Signature), 刚开始升级AS看到这个懵了,既然是APK Signature,就放心偷懒选了V2,结果安装失败？？？无奈,只能查资料… 从Android 7.0开始, 谷歌增加新签名方案 V2 Scheme (APK Signature); 但Android 7.0以下版本, 只能用旧签名方案 V1 scheme (JAR signing) V1签名: 来自JDK(jarsigner), 对zip压缩包的每个文件进行验证, 签名后还能对压缩包修改(移动/重新压缩文件) 对V1签名的apk/jar解压,在META-INF存放签名文件(MANIFEST.MF, CERT.SF, CERT.RSA), 其中MANIFEST.MF文件保存所有文件的SHA1指纹(除了META-INF文件), 由此可知: V1签名是对压缩包中单个文件签名验证 V2签名: 来自Google(apksigner), 对zip压缩包的整个文件验证, 签名后不能修改压缩包(包括zipalign), 对V2签名的apk解压,没有发现签名文件,重新压缩后V2签名就失效, 由此可知: V2签名是对整个APK签名验证 V2签名优点很明显: 签名更安全(不能修改压缩包) 签名验证时间更短(不需要解压验证),因而安装速度加快 注意: apksigner工具默认同时使用V1和V2签名,以兼容Android 7.0以下版本 2.zipalign和V2签名位于Android SDK/build-tools/SDK版本/zipalign.exe zipalign 是对zip包对齐的工具,使APK包内未压缩的数据有序排列对齐,从而减少APP运行时内存消耗 1zipalign -v &#96;&#96;4&#96; &#96;in.apk out.apk &#96;&#96;&#x2F;&#x2F;4字节对齐优化&#96;&#96;zipalign -c -v &#96;&#96;4&#96; &#96;in.apk &#96;&#96;&#x2F;&#x2F;检查APK是否对齐 zipalign可以在V1签名后执行 但zipalign不能在V2签名后执行,只能在V2签名之前执行！！！ 三、签名步骤1.生成密钥对(已有密钥库,可忽略)Eclipse或Android Studio在Debug时,对App签名都会使用一个默认的密钥库: 默认在C:\\Users\\用户名.android\\debug.keystore 密钥库名: debug.keystore 密钥别名: androiddebugkey 密钥库密码: android 生成密钥对 进入JDK/bin, 输入命令 keytool -genkeypair -keystore 密钥库名 -alias 密钥别名 -validity 天数 -keyalg RSA 参数: ​ -genkeypair 生成一条密钥对(由私钥和公钥组成)​ -keystore 密钥库名字以及存储位置(默认当前目录)​ -alias 密钥对的别名(密钥库可以存在多个密钥对,用于区分不同密钥对)​ -validity 密钥对的有效期(单位: 天)​ -keyalg 生成密钥对的算法(常用RSA/DSA,DSA只用于签名,默认采用DSA)​ -delete 删除一条密钥 提示: 可重复使用此条命令,在同一密钥库中创建多条密钥对 例如: ​ 在debug.keystore中新增一对密钥,别名是release 1keytool -genkeypair -keystore debug.keystore -alias release -validity 30000 2.查看密钥库 进入JDK/bin, 输入命令 keytool -list -v -keystore 密钥库名 参数: ​ -list 查看密钥列表​ -v 查看密钥详情 例如: 1keytool -list -v -keystore debug.keystore ​ 现在debug.keystore密钥库中有两对密钥, 别名分别是androiddebugkey release 3.签名方法一(jarsigner,只支持V1签名) 进入JDK/bin, 输入命令 jarsigner -keystore 密钥库名 xxx.apk 密钥别名 从JDK7开始, jarsigner默认算法是SHA256, 但Android 4.2以下不支持该算法, 所以需要修改算法, 添加参数 -digestalg SHA1 -sigalg SHA1withRSA jarsigner -keystore 密钥库名 -digestalg SHA1 -sigalg SHA1withRSA xxx.apk 密钥别名 参数: ​ -digestalg 摘要算法​ -sigalg 签名算法 例如: ​ 用JDK7及以上jarsigner签名,不支持Android 4.2 以下 1jarsigner -keystore debug.keystore MyApp.apk androiddebugkey ​ 用JDK7及以上jarsigner签名,兼容Android 4.2 以下 1jarsigner -keystore debug.keystore -digestalg SHA1 -sigalg SHA1withRSA MyApp.apk androiddebugkey 方法二(apksigner,默认同时使用V1和V2签名) 进入Android SDK/build-tools/SDK版本, 输入命令 apksigner sign –ks 密钥库名 –ks-key-alias 密钥别名 xxx.apk 若密钥库中有多个密钥对,则必须指定密钥别名 apksigner sign –ks 密钥库名 –ks-key-alias 密钥别名 xxx.apk 禁用V2签名 1apksigner sign --v2-signing-enabled &#96;&#96;false&#96; &#96;--ks 密钥库名 xxx.apk 参数: ​ –ks-key-alias 密钥别名,若密钥库有一个密钥对,则可省略,反之必选​ –v1-signing-enabled 是否开启V1签名,默认开启​ –v2-signing-enabled 是否开启V2签名,默认开启 例如: ​ 在debug.keystore密钥库只有一个密钥对 1apksigner sign --ks debug.keystore MyApp.apk ​ 在debug.keystore密钥库中有多个密钥对,所以必须指定密钥别名 1apksigner sign --ks debug.keystore --ks-key-alias androiddebugkey MyApp.apk","categories":[{"name":"等保2.0","slug":"等保2-0","permalink":"https://zofoa.github.io/categories/%E7%AD%89%E4%BF%9D2-0/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://zofoa.github.io/tags/Android/"},{"name":"证书签名","slug":"证书签名","permalink":"https://zofoa.github.io/tags/%E8%AF%81%E4%B9%A6%E7%AD%BE%E5%90%8D/"}]},{"title":"2020年个人年度总结","slug":"2020个人年度总结","date":"2020-12-29T07:34:04.000Z","updated":"2020-12-29T07:40:44.000Z","comments":true,"path":"2020/12/29/2020个人年度总结/","link":"","permalink":"https://zofoa.github.io/2020/12/29/2020%E4%B8%AA%E4%BA%BA%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/","excerpt":"","text":"2020年个人工作总结2020年，在质控部工作已经一年了，在这一年的时间中有收获、有成长。2020年已接近尾声了，总结我这一年的工作，总的来说是探索、责任、担当、忙碌。 来到新的部门，对于之前从事技术、测评工作的我质量管理完全是零起点，相关质量管理制度、流程办法都需要一点一点的去学习、探索。在新的部门中，我主要职责是完成项目质量评审工作，参与团队质量管理体系建设、质量考评等相关工作，在程老师的带领下，熟悉了质量管理工作的严谨公正、责任担当的精神。 今年，除了完成本职工作外，还参与了测评部的现场测评工作，带领小组完成项目测评。在测评项目中，担任项目负责人深感责任重大，现场需要协调一切事情，遇到自己不会的需要自己去不断学习，去提高自己的能力，去更好的解决问题。通过今年的项目现场测评实施，锻炼了自己，有成长、有收获，完全体会到了项目负责人的责任担当、技术实力、项目控制、沟通协调等能力要求。 在下半年中，是忙碌的，为能够保证测评部完成测评项目，从7月份开始陆续支援测评部开展项目测评，同时质控部的相关事情也要同时进行，在这个过程中总的来说是好的，但还是出现了一些不好、有待提高的事情。由于工作的性质比较特殊，工作中细节比较重要，往往被忽略的一个小小的问题可能就会造成一些安全隐患，所以在以后的工作中，我一定要认真对待每一件事情，做到积极、认真、负责。 回顾这一年，有失败、有成长、有收获，虽然没有真正意义上提高整体质量水平，但规范了质量管理的制度、方式、流程及标准，填补了公司之前的空白，希望在2021年质量控制工作更上一层楼。最后还是感谢，感谢公司提供这个良好工作平台，感谢领导和同事的支持和帮助。 2021年工作目标计划时间在流逝，世界在发展，外部因素越来越严峻，在这种形式下，只有严格要求自己，不断的学习提升自己，才会跟上世界的脚步。 居安思危，未雨绸缪，越是在繁荣昌盛之时，越要保持冷静，越是身处太平盛世，越要提高忧患意识。思则有备、有备无患，坚持末雨绸缪，才能在飞速前进的脚步中成长，在新的一年中，我要认真工作，完善自己，抱着忧患意识，争取做好每一件事情。 不忘初心，励志前行，希望不要忘记自己的最初意志，做到事前担责、事中尽责、事后负责，向着自己的梦想奋力前行。","categories":[{"name":"2020","slug":"2020","permalink":"https://zofoa.github.io/categories/2020/"}],"tags":[{"name":"年度总结","slug":"年度总结","permalink":"https://zofoa.github.io/tags/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"}]},{"title":"Word文档错别字检查工具","slug":"Word错别字扫描工具","date":"2020-06-21T12:32:33.000Z","updated":"2020-06-22T16:36:32.000Z","comments":true,"path":"2020/06/21/Word错别字扫描工具/","link":"","permalink":"https://zofoa.github.io/2020/06/21/Word%E9%94%99%E5%88%AB%E5%AD%97%E6%89%AB%E6%8F%8F%E5%B7%A5%E5%85%B7/","excerpt":"","text":"此程序用于检查Word文档中的错别字，使用此程序需自己提供错误字词库“1.md”以及对应正确字词库“2.md”。字词库内容以行区分，需放置程序同级目录。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import timefrom win32com import clientfrom colorama import Fore,Back,Style,initinit(autoreset=True)print(Back.BLACK + Fore.WHITE + Style.BRIGHT + \"************************************************************\")print(Back.BLACK + Fore.WHITE + Style.BRIGHT + \"*************** Word文档错别字检查工具V2.0 ***************\")print(Back.BLACK + Fore.WHITE + Style.BRIGHT + \"************************************************************\")print(Fore.MAGENTA + Style.BRIGHT + '''\\nPS：\\n 1、附件“1.md”为错别字库，每个错别字以行结尾；\\n 2、附件“2.md”为错别字库对应建议修改值；\\n 3、所有附件需放在此程序同级目录中;\\n 4、请保存已打开的Word文档，否则继续执行将自动关闭Word文档。\\n ''')print(Fore.GREEN + Style.BRIGHT + \"\\nloading......\\n\")#path = \"d:\\\\1.docx\"print(Fore.GREEN + Style.BRIGHT + \"请输入报告路径，例如：d:\\\\1.docx ；或鼠标拖拽报告到本程序框中。\\n\")path = (input('Path：'))start = time.time()print(Style.BRIGHT + \"\\n您输入的路径是：&#123;0&#125;\".format(path))print(Fore.GREEN + Style.BRIGHT + \"\\nloading......\\n\")def docxdate(docname): a=[] word = client.gencache.EnsureDispatch('Word.Application') doc = word.Documents.Open(docname) word.Visible = 0 # 后台运行 word.DisplayAlerts = 0 # 不显示，不警告 for p in doc.Paragraphs: a.append(p.Range.Text.strip()) print(Fore.GREEN + Style.BRIGHT + p.Range.Text.strip()) doc.Close() #doc.Close() //关闭 word 文档 #word.Quit() //关闭 office return '\\n'.join(a) docxcon = docxdate(path)con= open('./2.md','r',encoding='utf-8')a=[]for i in con: bcon=i.strip() a.append(bcon)textcon= open('./1.md','r',encoding='utf-8') #只读方式打开text文件b textcon= open('d:/1.md','r',encoding='utf-8') j=0z=0for i in textcon: linecon=i.strip() #Python strip() 方法用于移除字符串头尾指定的字符（默认为空格或换行符）或字符序列 z=z+1 if linecon in docxcon: j=j+1 d=z-1 c=a[d] print(Style.BRIGHT + \"\\ninfo &#123;0&#125;\".format(j)) print(Back.GREEN + Fore.WHITE + Style.BRIGHT + \"—————发现错别字： &#123;0&#125;\".format(linecon)) print(Back.GREEN + Fore.WHITE + Style.BRIGHT + \"—————建议替换为： &#123;0&#125;\".format(c))textcon.close()end = time.time()print(Style.BRIGHT + \"\\n\\nWord错别字检查已完成，共耗时 &#123;:.3f&#125; 秒，退出请按 ENTER ！\".format(end-start))input('') 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import timefrom win32com import clientfrom colorama import Fore,Back,Style,initinit(autoreset=True)print(Back.BLACK + Fore.WHITE + Style.BRIGHT + \"************************************************************\")print(Back.BLACK + Fore.WHITE + Style.BRIGHT + \"*************** Word文档错别字检查工具V3.0 ***************\")print(Back.BLACK + Fore.WHITE + Style.BRIGHT + \"************************************************************\")print(Fore.MAGENTA + Style.BRIGHT + '''\\nPS：\\n 1、附件“readme.md”为错别字库以及对应的正确值，每个错别字以行结尾；\\n 2、错别字库附件需放在此程序同级目录中;\\n 3、请保存已打开的Word文档，否则继续执行将自动关闭Word文档。\\n ''')print(Fore.GREEN + Style.BRIGHT + \"\\nloading......\\n\")#path = \"d:\\\\1.docx\"print(Fore.GREEN + Style.BRIGHT + \"请输入报告路径，例如：d:\\\\1.docx ；或鼠标拖拽报告到本程序框中。\\n\")path = (input('Path：'))start = time.time()print(Style.BRIGHT + \"\\n您输入的路径是：&#123;0&#125;\".format(path))print(Fore.GREEN + Style.BRIGHT + \"\\nloading......\\n\")def docxdate(docname): a=[] word = client.gencache.EnsureDispatch('Word.Application') doc = word.Documents.Open(docname) word.Visible = 0 # 后台运行 word.DisplayAlerts = 0 # 不显示，不警告 for p in doc.Paragraphs: a.append(p.Range.Text.strip()) print(Fore.GREEN + Style.BRIGHT + p.Range.Text.strip()) doc.Close() #doc.Close() //关闭 word 文档 #word.Quit() //关闭 office return '\\n'.join(a)docxcon = docxdate(path)b=[]j=0z=0con= open('./readme.md','r',encoding='utf-8')#只读方式打开text文件b textcon= open('d:/1.md','r',encoding='utf-8')for i in con: ccon=i.strip(\"\\n\") e1=ccon.split(\"/\",2)[0] e2=ccon.split(\"/\",2)[1] b.append(e2) z=z+1 if e1 in docxcon: j=j+1 d=z-1 c=b[d] print(Style.BRIGHT + \"\\ninfo &#123;0&#125;\".format(j)) print(Back.GREEN + Fore.WHITE + Style.BRIGHT + \"—————发现错别字： &#123;0&#125;\".format(e1)) print(Back.GREEN + Fore.WHITE + Style.BRIGHT + \"—————建议替换为： &#123;0&#125;\".format(c))con.close()end = time.time()print(Style.BRIGHT + \"\\n\\nWord错别字检查已完成，共耗时 &#123;:.2f&#125; 秒，退出请按 ENTER ！\".format(end-start))input('')","categories":[{"name":"Python编程","slug":"Python编程","permalink":"https://zofoa.github.io/categories/Python%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Python 3","slug":"Python-3","permalink":"https://zofoa.github.io/tags/Python-3/"}]},{"title":"Linux 系统审计功能","slug":"Linux 系统审计功能","date":"2020-05-14T05:00:00.000Z","updated":"2020-05-14T10:54:12.000Z","comments":true,"path":"2020/05/14/Linux 系统审计功能/","link":"","permalink":"https://zofoa.github.io/2020/05/14/Linux%20%E7%B3%BB%E7%BB%9F%E5%AE%A1%E8%AE%A1%E5%8A%9F%E8%83%BD/","excerpt":"","text":"Linux 系统审计功能audit主要用来记录安全信息，用于对系统安全事件的追溯；而 syslog 日志系统用来记录系统中的各种信息，如硬件警报和软件日志等。但是syslog 属于应用层，没办法记录太多信息。audit 来记录内核信息，包括文件的读写，权限的改变等。 通过auditctl -s命令查看auditd内核模块的状态,enabled为1表示启动，enabled为0表示停止，enabled为2表示规则锁定（重启后才能修改规则） 可以通过auditctl -e改变状态，0 不使能，1 使能，2 锁定配置。 enabled为1但auditd守护进程没有开启时，内核收集到的信息将会记录到写到/var/log/messages中 audit的审计规则大概有两类：一类是对文件的监控，一类是对系统调用的监控。 audit审计规则通过auditctl -l查看现在运行着的审计规则（默认是无规则No rules） 通过/etc/audit/audit.rules文件查看配置文件中的永久审计规则 对于文件，可以定义审计规则监控对该文件的读、写、执行等操作，一旦发生，就会记录到 日志文件中。 如对.bash_history文件的写和属性更改进行监控：auditctl -w /root/.bash_history -p wa 对于系统调用，可以定义审计规则对于命令的调用，比如用以下名监控对umask、chown命令的调用：auditctl -a exit,always -S umask -S chown audit事件工具audit提供三个工具aureport、ausearch、autrace有针对性地去统计分析以及跟踪log日志 aureport对于一个默认的、没有定义审计规则的系统，其实还是会记录一些东西的，我们可用aureport -i命令查看总览，使用-x、-l、-f、-c、-u、-p、-t可以查看各类记录的具体信息，默认情况下会对账号修改（passwd、usermod）、用户登录（图形界面的登录、远程登录）、配置修改等信息进行记录。 1234567aureport -u #对于用户在系统运行命令的生成的报告aureport -f #生成一个文件相关event的日志报告aureport -x #从可执行的角度去查看audit logaureport -s #system call的报告aureport -p #对于进程所有event的信息aureport -e #event事件列表aureport --failed #针对失败的event的统计，如果统计成功的用aureport --success 1aureport -if /var/log/audit/audit.log #-if指定一个audit log文件,统计它的总体的log报告 1aureport -l -if /var/log/audit/audit.log #统计log文件用户登录信息，可用 -ts 14:00 -te 15:00指定统计时间范围 1aureport -l -i #用户登录事件生成的报告 1aureport -t #查看audit log文件包含日志的起止时间 ausearchaureport帮助我们生成总体的日志总结， 如果我们对特定的event感兴趣，我们可以通过ausearch去过滤想要的日志。 ausearch - option -if myfile #可以指定特定的日志文件进行分析， 通过加上&quot;-i&quot;可以将数据格式的，转化成可读的文本格式，比如user ID 和ASCII 码形式的cmd。 12345678910111213141516171819ausearch -a 2984 #搜寻当期audit服务中event ID等于2984的logausearch -m #按消息类型查找ausearch -ul #按登陆ID查找ausearch -ua #按uid和euid查找ausearch -ui #按uid查找ausearch -ue #按euid查找ausearch -ga #按gid和egid查找ausearch -gi #按gid查找ausearch -ge #按egid查找ausearch -c #按cmd查找ausearch -x #按exe查找ausearch -sc #按syscall查找ausearch -p #按pid查找ausearch -sv #按syscall的返回值查找（yes/no）ausearch -f #按文件名查找ausearch -tm #按连接终端查找(term/ssh/tty)ausearch -hn #按主机名查找ausearch -k #按特定的key值查找ausearch -w #按在audit rule设定的字符串查找 autrace使用autrace命令跟踪指定进程，并将跟踪的结果写入日志文件之中。autrace生成的log会存放在/var/log/audit/audit.log。 当用autrace去跟踪一个进程时，为了保证避免autrace与之前audit rule生成的日志冲突，使用auditctl -D去停止所有的audit log, 当autrace结束后，使用systemctl restart auditd重启audit服务。 audit记录内容字段信息 字段 说明 Type 类型 msg 时间戳 success 成功/失败 pid 进程 id uid 对应进程的所有者ID auid 被审计的用户id，取决于登录状态 ses 进程的session ID exe 进程的执行文件的路径 name 具体被执行的路径或文件信息 comm 对应了进程执行的命令 syslog 系统日志 日志文件 说明 /var/log/wtmp 记录每个用户登录次数和登录时间(二进制文件，使用last查看) /var/log/btmp 记录用户错误登录信息(二进制文件，使用lastb命令查看) /var/log/utmp 记录当前已登录用户信息(二进制文件，使用w,who,users等查看) /var/log/lastlog 记录用户最后一次登录时间信息(二进制文件，使用lastlog查看) /var/log/message 系统标准错误日志信息（大多数产生的错误信息都在其中）、非内核产生的引导信息（如系统初始化信息）、各子系统产生的信息 /var/log/secure 与安全相关的信息(如用户登录、切换用户、修改密码) /var/log/maillogs 邮件系统产生的信息 syslog 系统日志记录内容字段信息各个日志文件记录的内容不相同，总体来说可以记录用户名、时间、类型、内容、结果等信息。","categories":[{"name":"等保2.0","slug":"等保2-0","permalink":"https://zofoa.github.io/categories/%E7%AD%89%E4%BF%9D2-0/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://zofoa.github.io/tags/Linux/"},{"name":"日志审计","slug":"日志审计","permalink":"https://zofoa.github.io/tags/%E6%97%A5%E5%BF%97%E5%AE%A1%E8%AE%A1/"}]},{"title":"Oracle数据库保密性和完整性配置测试","slug":"数据库保密性和完整性配置测试","date":"2020-05-12T14:04:26.000Z","updated":"2020-05-12T16:31:40.000Z","comments":true,"path":"2020/05/12/数据库保密性和完整性配置测试/","link":"","permalink":"https://zofoa.github.io/2020/05/12/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BF%9D%E5%AF%86%E6%80%A7%E5%92%8C%E5%AE%8C%E6%95%B4%E6%80%A7%E9%85%8D%E7%BD%AE%E6%B5%8B%E8%AF%95/","excerpt":"","text":"oracle 数据库远程连接抓包测试通过wireshare抓取oracle 11g连接数据包 设置wireshark过滤条件 ip.addr eq 192.168.0.133 and tns 测试发现数据明文传输的，未加密。 设置oracle 11g 连接加密理论上需要在数据库server端和oracle客户端都修改sqlnet.ora文件，但因为client端默认传输加密级别是ACCEPTED，默认一致性校验级别是ACCEPTED，所以只需要在服务器端设置如下参数就可以打开传输加密和一致性校验功能，而不需要再对client端的sqlnet.ora进行设置。 windows服务端设置方法打开C:\\app\\user\\product\\11.2.0\\dbhome_2\\NETWORK\\ADMIN\\sqlnet.ora Linux服务端设置方法find ./ -name sqlnet.ora //搜索sqlnet.ora文件，只要sqlnet.ora在\\NETWORK\\ADMIN\\路径就是对应要修改的文件位置 加密连接设置方法在sqlnet.ora文件中添加下列参数 1234SQLNET.ENCRYPTION_SERVER &#x3D; REQUIRED ----加密级别SQLNET.ENCRYPTION_TYPES_SERVER &#x3D; RC4_256 ----加密算法SQLNET.CRYPTO_CHECKSUM_SERVER &#x3D; REQUIRED ----完整性校验SQLNET.CRYPTO_CHECKSUM_TYPES_SERVER &#x3D; SHA1 ----完整性算法 可以设置的加密算法 加密算法名称 加密算法 RC4 256-bit key RC4_256 RC4 128-bit key RC4_128 RC4 56-bit key RC4_56 RC4 40-bit key RC4_40 AES 256-bit key AES256 AES 192-bit key AES192 AES 128-bit key AES128 3-key 3DES 3DES168 2-key 3DES 3DES112 DES 56-bit key DES DES 40-bit key DES40 可以设置的完整性算法 完整性算法名称 完整性算法 SHA-1 SHA1 sqlnet.ora文件服务端完整设置 重新启动oracle 抓包测试连接是否加密打开wireshark，设置抓取网卡开始抓包，使用工具连接数据库，进行sql语句查询。 设置wireshark过滤条件ip.addr eq 192.168.0.133 and tns 抓包完成，分析流发现数据库远程传输的数据已经被加密了 参考链接https://docs.oracle.com/cd/E11882_01/network.112/e40393/asoconfg.htm#ASOAG9599","categories":[{"name":"等保2.0","slug":"等保2-0","permalink":"https://zofoa.github.io/categories/%E7%AD%89%E4%BF%9D2-0/"}],"tags":[{"name":"完整性","slug":"完整性","permalink":"https://zofoa.github.io/tags/%E5%AE%8C%E6%95%B4%E6%80%A7/"},{"name":"保密性","slug":"保密性","permalink":"https://zofoa.github.io/tags/%E4%BF%9D%E5%AF%86%E6%80%A7/"}]},{"title":"双向身份验证机制","slug":"双向身份验证机制","date":"2020-04-29T05:38:49.000Z","updated":"2020-04-29T05:45:40.000Z","comments":true,"path":"2020/04/29/双向身份验证机制/","link":"","permalink":"https://zofoa.github.io/2020/04/29/%E5%8F%8C%E5%90%91%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E6%9C%BA%E5%88%B6/","excerpt":"","text":"双向身份验证机制管理终端和云计算平台之间应建立双向身份验证机制 典型案例阿里云的访问控制RAM（Resource Access Management）服务 Ram 是主账户授权认证，基于用户角色授权后基于api访问云服务资源时，通过访问密钥accesskey进行认证，认证资源后，还会有一次阿里云临时安全令牌（Security Token Service，STS）的认证，就可以管理资源了。 实现原理彼此之间的互相认证，A B间的双向认证需要C去做核验。 实现方法一般基于证书。如，CA证书、基于https的证书 客户端被认证通过ca证书实现，服务器端认证通过https实现 参考文档https://help.aliyun.com/document_detail/163277.html?spm=5176.10695662.1996646101.searchclickresult.26691487v65ZaR&amp;aly_as=5Jz9HGTEx https://help.aliyun.com/document_detail/28756.html https://help.aliyun.com/document_detail/160093.html?spm=5176.10695662.1996646101.searchclickresult.466b2721miKztv&amp;aly_as=TgpMEhjh9 https://www.jianshu.com/p/2b2d1f511959?utm_campaign=haruki https://www.freebuf.com/company-information/207267.html","categories":[{"name":"等保2.0","slug":"等保2-0","permalink":"https://zofoa.github.io/categories/%E7%AD%89%E4%BF%9D2-0/"}],"tags":[{"name":"身份鉴别","slug":"身份鉴别","permalink":"https://zofoa.github.io/tags/%E8%BA%AB%E4%BB%BD%E9%89%B4%E5%88%AB/"}]},{"title":"数据库保密性技术实现措施","slug":"数据库保密性技术实现措施","date":"2020-04-26T06:59:13.000Z","updated":"2020-05-12T16:12:57.820Z","comments":true,"path":"2020/04/26/数据库保密性技术实现措施/","link":"","permalink":"https://zofoa.github.io/2020/04/26/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BF%9D%E5%AF%86%E6%80%A7%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0%E6%8E%AA%E6%96%BD/","excerpt":"","text":"Oracle 透明数据加密(TED)Oracle Advanced Security 透明数据加密 (TDE) 通过在数据库层执行静止数据加密，阻止可能的攻击者绕过数据库直接从存储读取敏感信息。经过数据库身份验证的应用和用户可以继续透明地访问应用数据（不需要更改应用代码或配置），而尝试读取表空间文件中的敏感数据的 OS 用户以及尝试读取磁盘或备份信息的不法之徒将不允许访问明文数据。 可与 TDE 一同使用的加密算法TDE 支持 AES256、AES192（列加密默认算法）、AES128（表空间加密默认算法）和 3DES168。 TDE 加密后数据在网络传输过程不加密使用 TDE 加密后的数据在从数据库文件中读回时会被解密。因此，如果在网络上传输该数据，它将处于明文状态。不过，客户可以使用 Oracle 的网络加密解决方案（示例）对这些数据进行加密，该方案和 TDE 一同包含在 Oracle Advanced Security 选件中。Oracle 的网络加密解决方案可以对通过 SQL*Net 与数据库往来传输的所有数据进行加密。 参考文档Oracle Database 11g 中使用透明数据库加密 透明数据加密 (TDE)常见问题解答 Oracle 数据网络传输加密客户端连接数据库传输加密客户端和数据库服务器之间数据传输是明文的，通过wireshark抓包工具可以看到，不管是客户端的请求sql（request sql），还是服务器的应答数据（response data），都是明文传输的，在一些特殊的场景下是不安全的，因此，为了传输保密性可以使用oracle自带的安全组件，实现数据加密传输。 客户端存在两种模式1、通过oracle客户端软件连接数据库 2、通过jdbc驱动连接oracle数据库 通过oracle客户端软件连接数据库情况启用传输加密和校验的主要方法是通过服务器端和客户端的sqlnet.ora文件实现。 配置如下 理论上需要在数据库server端和oracle客户端都修改sqlnet.ora文件，但因为client端默认传输加密级别是ACCEPTED，默认一致性校验级别是ACCEPTED，所以只需要在服务器端设置如下参数就可以打开传输加密和一致性校验功能，而不需要再对client端的sqlnet.ora进行设置。 在Oracle服务器端/u01/app/oracle/product/11.2.0/db_1/network/admin下的sqlnet.ora文件中加入下面配置 123SQLNET.ENCRYPTION_SERVER = REQUIRED ----加密级别SQLNET.ENCRYPTION_TYPES_SERVER = RC4_256 ----加密算法SQLNET.CRYPTO_CHECKSUM_SERVER = REQUIRED ----一致性能校验 通过jdbc驱动连接oracle数据库情况大体格式如下： 1234567DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());Properties props = new Properties();props.put(\"oracle.net.encryption_client\", \"accepted\");props.put(\"oracle.net.encryption_types_client\", \"RC4_128\");props.put(\"oracle.net.crypto_checksum_client\", \"REQUIRED\"); //此行根据官方文档写，未作验证props.put(\"oracle.net.crypto_checksum_types_client\",\"MD5\"); //此行根据官方文档格式写，未作验证props.put(\"user\", \"XXX\"); props.put(\"password\", \"YYY\"); Connection conn = DriverManager.getConnection(\"jdbc:oracle:thin:@myhost:1521:mySID\", props); 服务器上配置网络数据加密要在Oracle数据库服务器上配置网络数据加密，请执行以下步骤： 1、在操作系统提示符下输入netmgr。 1[oracle@host01 ~]$ netmgr 2、显示“ Oracle Net Manager欢迎”页面。展开本地。 3、选择Profile。在右边选项菜单中选择“ Oracle Advanced Security”。 4、单击加密选项卡“Encruption”。 5、验证“Encruption”字段是否设置为“SERVER”。在“Encruption Type”菜单中选择“required”。在“Encruption Seed”字段中输入少于70个随机字符。通过在“Available Methods”列表中突出显示该加密方法，然后单击&gt;将其移动到“Selected Methods”列表中，来选择加密方法。 6、菜单栏选择file-&gt;Save Network Configuration以保存更改。 7、菜单栏选择file-&gt;Exit 退出Oracle Net Manager。 性能影响加密和解密就势必会占用一定的性能资源，但影响不大，下图是一个测试结果，摘自http://www.orafaq.com/wiki/Network_Encryption Algorithm None MD5 SHA-1 Time Time %None Time %None Time %None None 79.6 s 80.5 s 101% 82.4 s 104% DES 104.7 s 132% 107.1 s 135% 108.2 s 136% 3DES168 151.8 s 191% 153.9 s 193% 155.6 s 196% AES128 88.8 s 112% 90.5 s 114% 92.1 s 116% AES256 91.8 s 115% 93.5 s 117% 94.2 s 118% RC4_128 81.6 s 103% 82.5 s 104% 85.0 s 107% RC4_256 81.7 s 103% 82.8 s 104% 85.0 s 107% 参考文档http://docs.oracle.com/cd/B19306_01/network.102/b14268/asoconfg.htm#BBJBIECD http://docs.oracle.com/cd/B19306_01/network.102/b14268/asojbdc.htm#i1006209 http://www.orafaq.com/wiki/Network_Encryption http://www.toadworld.com/platforms/oracle/w/wiki/1719.sqlnet-ora-parameters https://www.cnblogs.com/KQNLL/p/8626435.html SQL Server 透明数据加密（TDE）在SQL Server2000和以前的版本，是不支持加密的。所有的加密操作都需要在程序中完成。这导致一个问题，数据库中加密的数据仅仅是对某一特定程序有意义，而另外的程序如果没有对应的解密算法，则数据变得毫无意义。 到了SQL Server2005，引入了列级加密。使得加密可以对特定列执行，这个过程涉及4对加密和解密的内置函数 SQL Server 2008时代，则引入的了透明数据加密（TDE），所谓的透明数据加密，就是加密在数据库中进行，但从程序的角度来看就好像没有加密一样，和列级加密不同的是，TDE加密的级别是整个数据库。使用TDE加密的数据库文件或备份在另一个没有证书的实例上是不能附加或恢复的。 数据库文件加密在页面级执行。 已加密数据库中的页在写入磁盘之前会进行加密，在读入内存时会进行解密。 TDE 不会增加已加密数据库的大小。 启用 TDE 时，应该立即备份证书和与证书相关联的私钥。 如果证书变为不可用，或者如果必须在另一台服务器上还原或附加数据库，则必须同时具有证书和私钥的备份，否则将无法打开该数据库。 即使不再对数据库启用 TDE，也应该保留加密证书。 即使数据库未加密，事务日志的某些部分仍可能保持受到保护，但在执行数据库的完整备份前，对于某些操作可能需要证书。 超过过期日期的证书仍可以用于通过 TDE 加密和解密数据。 参考文档https://docs.microsoft.com/zh-cn/sql/relational-databases/security/encryption/transparent-data-encryption?view=sql-server-ver15 SQL Server 数据库加密连接SQL Server 可以使用传输层安全性 (TLS) 对通过网络在 SQL Server 实例与客户端应用程序之间传输的数据进行加密。 TLS 加密在协议层执行，并可用于所有支持的 SQL Server 客户端。 客户端连接请求加密时，TLS 可用于服务器验证。 如果 SQL Server 实例在某个计算机上运行，该计算机已分配有一个由公共证书颁发机构颁发的证书，则计算机的标识和 SQL Server 实例由受信任的根证书颁发机构的证书链担保。 这种服务器验证需要对运行客户端应用程序的计算机进行配置，使其信任服务器使用的证书的根证书颁发机构。 也可以使用带有自签名的证书进行加密，但是自签名证书只能提供有限的保护。 TLS 使用的加密级别是 40 位还是 128 位，取决于应用程序和数据库计算机上运行的 Microsoft Windows 操作系统版本。 参考文档https://docs.microsoft.com/zh-cn/sql/database-engine/configure-windows/enable-encrypted-connections-to-the-database-engine?view=sql-server-ver15","categories":[{"name":"等保2.0","slug":"等保2-0","permalink":"https://zofoa.github.io/categories/%E7%AD%89%E4%BF%9D2-0/"}],"tags":[{"name":"完整性","slug":"完整性","permalink":"https://zofoa.github.io/tags/%E5%AE%8C%E6%95%B4%E6%80%A7/"},{"name":"保密性","slug":"保密性","permalink":"https://zofoa.github.io/tags/%E4%BF%9D%E5%AF%86%E6%80%A7/"}]},{"title":"01 Python基础","slug":"01 Python基础","date":"2020-04-09T06:04:11.000Z","updated":"2020-04-26T11:55:22.000Z","comments":true,"path":"2020/04/09/01 Python基础/","link":"","permalink":"https://zofoa.github.io/2020/04/09/01%20Python%E5%9F%BA%E7%A1%80/","excerpt":"","text":"1在人生中取得成功， 与其说靠天才与机会， 不如说靠专注与毅力。 ——C. W. Wendte 安装VScode 设置为中文语言环境，快捷键Ctrl+Shift+P，搜索框中输入configure language 1、基础注释 # ，任何存在#号右侧的文字，注释可以单行，也可以在代码行后面接注释 2、字面常量如“1、2.2、this is a book、这是一本书”，字面常量字面意义上的值或是内容，因为它的值不能被改变。 3、数字数字主要分为两种类型——整数（ Integers） 与浮点数（ Floats） ，有关整数的例子即 2 ， 它只是一个整数。有关浮点数（ Floating Point Numbers， 在英文中也会简写为 floats ） 的例子是 3.23 或52.3E-4 。 其中， E 表示 10 的幂。 在这里， 52.3E-4 表示 52.3 * 10^-4。 4、字符串一串字符串（ String） 是 字符（ Characters） 的 序列（Sequence） 。 基本上， 字符串就是一串词汇。 5、单引号你可以使用单引号来指定字符串， 例如 ‘将我这样框进来’ 或 ‘Quote me on this’ 。所有引号内的空间， 诸如空格与制表符， 都将按原样保留。 6、双引号被双引号包括的字符串和被单引号括起的字符串其工作机制完全相同。 例如 “你的名字是？ “ 或“What’s your name?” 。 7、三引号你可以通过使用三个引号—— “”” 或 ‘’’ 来指定多行字符串。 你可以在三引号之间自由地使用单引号与双引号。 来看看这个例子： 8、格式化方法从其他信息中构建字符串， 这正是 format() 方法大有用武之地的地方。 12345678910111213输入name=\"haha\"age=11print('姓名是&#123;&#125;,年龄&#123;&#125;'.format(name,age))print('年龄是&#123;1&#125;,姓名&#123;0&#125;'.format(name,age))print('姓名是'+name+'，年龄'+str(age))输出结果HelloWorld姓名是haha,年龄11年龄是11,姓名haha姓名是haha，年龄11 Python 中 format 方法所做的事情便是将每个参数值替换至格式所在的位置。 这之中可以有更详细的格式， 例如： 12345678910111213141516171819对于浮点数 '0.333' 保留小数点(.)后三位print('&#123;0:.3f&#125;'.format(3/2))使用下划线填充文本， 并保持文字处于中间位置使用 (^) 定义 '___hello___'字符串长度为 11print('&#123;0:_^11&#125;'.format('hello'))基于关键词输出 '呵呵 wrote 简明的'print('&#123;name&#125; wrote &#123;book&#125;'.format(name='呵呵', book=\"简明的\"))输出结果1.500___hello___呵呵 wrote 简明的 print 总是会以一个不可见的“新一行”字符（ \\n ）结尾，防止打印换行符用end=’’指定其应以空白结尾，或者你通过 end 指定以空格结尾：end=’ ‘，或者end=’任何内容，，，，’ 9、转义序列如果你希望生成一串包含单引号（ ‘ ） 的字符串， 需通过 \\ 来指定单引号： 要注意它可是反斜杠 指定一串双行字符串,一种方式即使用如前所述的三引号字符串， 或者可以使用一个表示新一行的转义序列—— \\n 来表示新一行的开始。 下面是一个例子：’This is the first line\\nThis is the second line’ 另一个大有用处的转义序列是制表符： \\t 在一个字符串中， 一个放置在末尾的反斜杠表示字符串将在下一行继续， 但不会添加新的一行。 如下： 10、原始字符串如果需要指定一些未经过特殊处理的字符串， 比如转义序列， 那么你需要在字符串前增加r 或 R 来指定一个 原始（ Raw） 字符串 。 11、变量如果只使用字面常量很快就会让人感到无聊——我们需要一些能够存储任何信息并且也能操纵它们的方式。 这便是 变量（ Variables） 登场的时刻。 正如其名字所述那般， 变量的值是可以变化的， 也就是说， 你可以用变量来存储任何东西。 变量只是你的计算机内存中用以存储信息的一部分。 与文字常量不同， 你需要通过一些方式来访问这些变量， 因此， 你需要为它们命名。 12、标识符命名变量是标识符的一个例子。 标识符（ Identifiers） 是为 某些东西 提供的给定名称。 在你命名标识符时， 你需要遵守以下规则： 第一个字符必须是字母表中的字母（ 大写 ASCII 字符或小写 ASCII 字符或 Unicode 字符） 或下划线（ _ ） 。标识符的其它部分可以由字符（ 大写 ASCII 字符或小写 ASCII 字符或 Unicode 字符） 、下划线（ _ ） 、 数字（ 0~9） 组成。标识符名称区分大小写。 例如， myname 和 myName 并不等同。 要注意到前者是小写字母 n 而后者是大写字母 N 。有效 的标识符名称可以是 i 或 name_2_3 ， 无效 的标识符名称可能是2things ， this is spaced out ， my-name 和 &gt;a1b2_c3 。 13、数据类型变量可以将各种形式的值保存为不同的数据类型（ Data Type） 。 基本的类型是我们已经讨论过的数字与字符串。 在后面的章节中， 我们会了解如何通过 类（ Classes） 类创建我们自己的类型。 14、对象需要记住的是， Python 将程序中的任何内容统称为 对象（ Object） 。 这是一般意义上的说法。 我们以“某某对象（ object） ”相称， 而非“某某东西（ something） ”。 针对面向对象编程语言用户的提示：Python 是强（ Strongly） 面向对象的， 因为所有的一切都是对象， 包括数字、 字符串与函数。 16、使用变量与字面常量变量只需被赋予某一值。 不需要声明或定义数据类型 17、逻辑行与物理行所谓物理行（ Physical Line） 是你在编写程序时 你所看到 的内容。 所谓逻辑行（ LogicalLine） 是 Python 所看到 的单个语句。 Python 会假定每一 物理行 会对应一个 逻辑行。 Python 之中暗含这样一种期望： Python 鼓励每一行使用一句独立语句从而使得代码更加可读。例如 123456789101112i = 5print(i)实际上等同于i = 5;print(i);同样可以看作i = 5; print(i);也与这一写法相同i = 5; print(i) 17、缩进空白区 在 Python 中十分重要。 实际上， 空白区在各行的开头非常重要。 这被称作 缩进（ Indentation） 。 在逻辑行的开头留下空白区（ 使用空格或制表符） 用以确定各逻辑行的缩进级别， 而后者又可用于确定语句的分组。这意味着放置在一起的语句必须拥有相同的缩进。 每一组这样的语句被称为 块（ block） 。 1234567如何缩进使用四个空格来缩进。 这是来自 Python 语言官方的建议。 好的编辑器会自动为你完成这一工作。 请确保你在缩进中使用数量一致的空格， 否则你的程序将不会运行， 或引发不期望的行为。针对静态编程语言程序员的提示Python 将始终对块使用缩进， 并且绝不会使用大括号。 你可以通过运行 from__future__ import braces 来了解更多信息。 18、运算符与表达式你所编写的大多数语句（ 逻辑行） 都包含了表达式（ Expressions） 。 一个表达式的简单例子便是 2+3 。 表达式可以拆分成运算符（ Operators） 与操作数（ Operands）。例子中 2 和 3 就是操作数。 19、控制流","categories":[{"name":"Python编程","slug":"Python编程","permalink":"https://zofoa.github.io/categories/Python%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Python 3","slug":"Python-3","permalink":"https://zofoa.github.io/tags/Python-3/"}]},{"title":"二十几岁需要掌握的5种能力","slug":"二十几岁需要掌握的5种能力","date":"2020-03-24T13:30:31.030Z","updated":"2020-03-24T13:34:02.000Z","comments":true,"path":"2020/03/24/二十几岁需要掌握的5种能力/","link":"","permalink":"https://zofoa.github.io/2020/03/24/%E4%BA%8C%E5%8D%81%E5%87%A0%E5%B2%81%E9%9C%80%E8%A6%81%E6%8E%8C%E6%8F%A1%E7%9A%845%E7%A7%8D%E8%83%BD%E5%8A%9B/","excerpt":"","text":"[TOC] 二十几岁需要掌握的5种能力1、良好的表达能力 《情商高就是会说话》 2、社交职称人脉的掌控能力 《气场》 3、高效人际关系的沟通能力 《沟通的智慧》 4、独立思考的学习能力 《思维风暴》 5、坚定自我坚持不懈的执着能力 《熬得住出众，熬不住出局》 《方与圆》1234567方是 **做人之本**圆是 **处世之道**方是 **原则目标**圆是 **策略手段 当你的才华配不上你的梦想的时候一定要放低梦想去追逐才华！ 当你的能力配不上你的消费的时候 一定要降低消费去提升能力！ 去学习 去进步 去进化 与其降低你的开支，不如去尝试增加你的收入，这就是我努力的理由。 十大堕落的表现123456789101112131415161718192021222324251、早晨从中午开始2、晚上12点以后才睡觉3、越来越懒《生活给你的一定是能能承受的》4、时间基本花在了电脑手机5、不管做什么事都没兴趣6、经常发呆 莫名烦躁《人生的谷底怎么走都向上》7、严重缺乏锻炼8、沉迷于游戏9、三餐饮食不均10、与家人缺少交流《别让人生输给了心情》 求知若饥 虚心若愚——乔布斯坚持遇见更好的自己123456789101112131415161718192021222324252627282930313233每一天1、早睡早起，保证7-8小时的睡眠2、花20-60分钟去阅读3、花20-40分钟去健身4、吃2个水果5、拍一张当天的照片6、至少走满5000步7、花15-30分钟护理你的皮肤每一周1、给父母打一次电话2、花3-12小时学习或者提升一门技能3、下一次厨，学会烹饪,可以让你更好的照顾自己4、花2-6个小时,参加一次有意义的活动每一月1、每个月看一次电影2、写一些文字记录，自己的思考或生活3、结识1位新的朋友4、读完一本书每一年1、来一场说走就走的旅行2、带上家人，做一次全面体检3、在远方的你，尽量多回几次家4、丢弃一些不需要的东西5、视自己经济能力，给父母一个大红包6、给自己一个奖励，什么都行7、做一次全面的年度总结和次年规划 女人要嫁就嫁给一个很温暖的男人123456789101112找一个会帮你擦干头发会低头给你系鞋带会吃你吃剩下的东西会在你来大姨妈的时候给你冲红糖水喝会牵着你的手过马路会在纪念日给你惊喜会把你介绍给所有的朋友会包容你的脾气会和你认错的人把你捧在手心里像日出日落一样陪着你 决定你人生上限的是你的自律12345身材好，说明你在嘴上自律。气质好，说明你在学习和修心方面自律。人缘好，说明你在脾气上自律。事业好，说明你在时间、精力、体力、心力很多方面都自律。自律，才能遇见更好的自己。 释迦牟尼说的一句话：1“无论你遇见谁，他都是你生命该出现的人，绝非偶然，他一定会教会你一些什么”。 少女的祈祷12345我想要花不是我告诉你我想要花所以你要送我花而是你想送我花所以我才要花 如果未尝过苦 自然也尝不出甜幸福大概就是：你喜欢粘着的那个人，永远都不会嫌你烦。陪伴最重要1陪在身边才是拥有，爱到习惯才会长久 喜欢和爱的区别1234567891011121314151617喜欢是红着脸 ，爱是红着眼。喜欢是我很快乐，爱是我想让你快乐。喜欢是想得到，爱是想保护。喜欢是心动，爱是心定。喜欢是一种天性，爱是一种忠诚。喜欢是靠嘴说，爱是靠行动去做。喜欢是初见不厌，爱是久处不厌。喜欢是想得到，爱是怕失去。喜欢是我把糖果拿地出来，我们一起吃；爱是我把糖果拿出来，我看着你吃。 人际交往中悟出的道理12345678910111213不喜欢麻烦别人的人，一般也不喜欢被别人麻烦。能花钱解决的事情，干万别用人情解决。不要关系好一点就口无遮拦。人前不应该说的话，背后也别说。初次见面时，一定要记住对方的名字。在在一个桌子上吃饭的人，不一定叫人脉；但是能互相交换资源的人，那一定是人脉。有钱才敢做真实的自己，没钱的话，只能做别人喜欢的自己。 三观最正的话123彩礼和嫁妆是两个家庭帮助一个新的家庭，而不是一个家庭给另一个家庭扶贫，这是我听过三观最正的话 提升口才的方法123451、每天要练习口部操，要练习绕口令。要练习你的气息，让你很好的去控制你的口腔和你的声音的状态。2、每天要去模仿一个高手说话的技巧，把他说话的方式提炼出他的语言逻辑，然后举一反三，去学习他的语言框架。3、每天要看书要做笔记，积累好词好句，还有它的表达方式。 写在清华墙上的七句话1.我荒废的今日正是昨天殒身之人祈求的明天2.请享受无法回避的痛苦3.觉得自己为时已晚的时候恰恰是最早的时候4.谁也不可能轻易成功它来自彻底的自我管理和毅力5.现在流的口水，将成为明天的眼泪6.今天不走，明天要跑7.即使此刻对手也在不停地翻动书页","categories":[],"tags":[]},{"title":"往昔不念 来日可期","slug":"1","date":"2019-04-25T15:52:00.000Z","updated":"2020-11-13T07:01:02.000Z","comments":true,"path":"2019/04/25/1/","link":"","permalink":"https://zofoa.github.io/2019/04/25/1/","excerpt":"","text":"往昔不念，来日可期！我突然间想通了，我们本不应该相遇的，就算再喜欢你 我也不要了，因为没有纠缠你的勇气了，也没有那份执着 放过你 就等于放过我自己。 我对你的温度，取决于你对我的态度。 如果给不了我想要的态度，请不要靠近我。 再见！ 2020.08.22","categories":[],"tags":[{"name":"来日可期","slug":"来日可期","permalink":"https://zofoa.github.io/tags/%E6%9D%A5%E6%97%A5%E5%8F%AF%E6%9C%9F/"}]},{"title":"CTF-Windows内存取证 基础知识","slug":"CTF-Windows内存取证-基础知识","date":"2019-04-22T15:47:07.000Z","updated":"2020-04-25T11:30:58.000Z","comments":true,"path":"2019/04/22/CTF-Windows内存取证-基础知识/","link":"","permalink":"https://zofoa.github.io/2019/04/22/CTF-Windows%E5%86%85%E5%AD%98%E5%8F%96%E8%AF%81-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","excerpt":"","text":"本文主要介绍利用Volatility内存取证工具对windows系统内存镜像进行分析。 内存取证内存取证是指通过对计算机物理内存和页面交换文件中进行查找、提取并进行分析，继而得到我们需要的证据的过程；可以形象的理解为将内存进程写入镜像文件，通过镜像文件查看之前内存进程的一些信息。 取证工具 Volatility Volatility是一款开源的，基于Python开发的内存取证工具集，可以分析内存中的各种数据。Volatility支持对32位或64位Wnidow、Linux、Mac、Android操作系统的RAM数据进行提取与分析。 DumpIt DumpIt 是一款绿色免安装的 windows 内存镜像取证工具。利用它我们可以轻松地将一个系统的完整内存镜像下来，并用于后续的调查取证工作。下载后，直接双击运行 exe 文件，输入 y 并回车，软件就会在当前目录下保存内存镜像文件。 Procdump Windows平台下的命令行工具，可以在指定的条件下生成dump文件，主要用于高CPU占用率的性能分析优化，程序停止响应的调试，First chance异常捕获等，还可以监视内存使用、结合系统性能计数器使用，更详细介绍见官方网站。 这里只记录一下常用用法。 在命令提示符下procdump -?可以查看全部参数的说明 123456这里列举几个常用的：-c/-cl: 监视CPU占用率阀值，-c为当CPU占用率高于该值时创建dump，-cl则在低于该值时创建dump。-u: 监视单核心的CPU占用率，与-c一起使用-s: 时间，以秒为单位，结合-c使用实现当连续N秒CPU占用高于某值时保存dump。-n: 设置数量，保存多个dump后才退出该程序。-h: 当进程中存在挂起窗口（不响应窗口消息）时创建dump。 分析内存中隐藏的秘密获取内存镜像通过dumplt获取了一台Server 2003服务器的内存镜像，内存镜像notepad++中有一些重要信息,我们需要获取重要数据。 使用Volatility对内存镜像进行分析 volatility命令手册，可访问该链接查看工具命令使用介绍。 12345678910111213常用的命令：cmdline/cmdscan 列出历史cmd命令filescan 扫描文件，可配合grep使用netscan 扫描建立的连接和套接字，类似于netstatpslist/psscan 列出进程列表svcscan 扫描windows服务列表screenshot 显示GDI样式的截屏memdump 从内存dump进程的内存dumpfiles 从内存dump文件connscan 建立的地址池连接-h或者–help 列举出所有可用的选项以及插件–info 打印出所有已经注册的对象(插件) 进入1.raw文件所在目录，使用volatility获取镜像基本信息。 12volatility -f 1.raw imageinfoimageinfo命令：用于查看我们正在分析的内存样本的摘要信息。具体来说显示主机所使用的操作系统版本、服务包以及硬件结构(32位或64位)、页目录表的起始地址和该获取该内存镜像的时间等基本信息。 使用pslist命令查看当前镜像运行的进程信息。 12345volatility -f 1.raw pslist --profile=Win2003SP1x86pslist命令: 可以枚举系统中的进程，这条命令通过遍历PsActiveProcessHead指针指向的双向链表枚举当前内存中活跃的所有进程信息，主要包括偏移地址、进程ID号、父进程ID号、线程数量、句柄数量、进程会话ID号以及进程开始和退出的时间。pslist: 无法显示隐藏/终止进程。psscan: 输出的内容会比pslist多。pstree: 扫描进程，以进程树的形式出现。 查看cmd 输入的内容 123volatility -f 1.raw --profile&#x3D;Win2003SP1x86 cmdscancmdscan命令: 可以用来查看受害者系统上攻击者操作的最强大的命令之一，无论他们是否打开cmd.exe简单地说，您可以看到攻击者在命令提示符中键入的内容。 查看可疑文件 123456volatility -f 1.raw --profile&#x3D;Win2003SP1x86 filescanfilescan命令: 扫描当前打开的文件。配合 dumpfile有意想不到的效果 dumpfiles -D .&#x2F; -Q查看文档、图片、桌面文件volatility -f 1.raw --profile&#x3D;Win2003SP2x86 filescan | grep &quot;doc\\|docx\\|rtf&quot;volatility -f 1.raw --profile&#x3D;Win2003SP2x86 filescan | grep &quot;jpg\\|jpeg\\|png\\|tif\\|gif\\|bmp&quot;volatility -f 1.raw --profile&#x3D;Win2003SP2x86 filescan | grep &quot;Desktop&quot; 查看命令行输入 1volatility -f 1.raw --profile&#x3D;Win2003SP2x86 cmdline 查看系统用户名 1volatility -f 1.raw --profile&#x3D;Win2003SP2x86 printkey -K &quot;SAM\\Domains\\Account\\Users\\Names&quot; 查看网络连接 1volatility -f 1.raw --profile&#x3D;Win2003SP2x86 netscan 导出notepad++ 进程内存 1volatility -f 1.raw --profile&#x3D;Win2003SP2x86 memdump -p 3324 --dump-dir&#x3D;.&#x2F; 查看notepad++隐藏的重要信息我们使用内存取证分析工具对内存镜像的一些基本信息进行了分析，发现了内存中存在notepad++进程，使用相关技术手段把notepad++进程导出dmp文件格式，下面我们使用二进制编辑器hexeditor打开1188.dmp查看寻找隐藏的信息 PS: 也可以使用 strings 这个工具将它的字符串打印出来 12strings 1188.dmp &gt; &gt;&gt;1188.txtstrings 1188.dmp &gt; 3324.txt | grep flag 如上图所示，红框中的flag值就是我们需要重要数据。 全文结束 谢谢大家观看！如有错误或其它技术交流问题，请留言反馈。","categories":[{"name":"计算机电子取证","slug":"计算机电子取证","permalink":"https://zofoa.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%94%B5%E5%AD%90%E5%8F%96%E8%AF%81/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://zofoa.github.io/tags/CTF/"},{"name":"内存取证","slug":"内存取证","permalink":"https://zofoa.github.io/tags/%E5%86%85%E5%AD%98%E5%8F%96%E8%AF%81/"}],"author":"ZOFOA"}],"categories":[{"name":"等保2.0","slug":"等保2-0","permalink":"https://zofoa.github.io/categories/%E7%AD%89%E4%BF%9D2-0/"},{"name":"2020","slug":"2020","permalink":"https://zofoa.github.io/categories/2020/"},{"name":"Python编程","slug":"Python编程","permalink":"https://zofoa.github.io/categories/Python%E7%BC%96%E7%A8%8B/"},{"name":"计算机电子取证","slug":"计算机电子取证","permalink":"https://zofoa.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%94%B5%E5%AD%90%E5%8F%96%E8%AF%81/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://zofoa.github.io/tags/Linux/"},{"name":"主机加固","slug":"主机加固","permalink":"https://zofoa.github.io/tags/%E4%B8%BB%E6%9C%BA%E5%8A%A0%E5%9B%BA/"},{"name":"网络","slug":"网络","permalink":"https://zofoa.github.io/tags/%E7%BD%91%E7%BB%9C/"},{"name":"Android","slug":"Android","permalink":"https://zofoa.github.io/tags/Android/"},{"name":"证书签名","slug":"证书签名","permalink":"https://zofoa.github.io/tags/%E8%AF%81%E4%B9%A6%E7%AD%BE%E5%90%8D/"},{"name":"年度总结","slug":"年度总结","permalink":"https://zofoa.github.io/tags/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"},{"name":"Python 3","slug":"Python-3","permalink":"https://zofoa.github.io/tags/Python-3/"},{"name":"日志审计","slug":"日志审计","permalink":"https://zofoa.github.io/tags/%E6%97%A5%E5%BF%97%E5%AE%A1%E8%AE%A1/"},{"name":"完整性","slug":"完整性","permalink":"https://zofoa.github.io/tags/%E5%AE%8C%E6%95%B4%E6%80%A7/"},{"name":"保密性","slug":"保密性","permalink":"https://zofoa.github.io/tags/%E4%BF%9D%E5%AF%86%E6%80%A7/"},{"name":"身份鉴别","slug":"身份鉴别","permalink":"https://zofoa.github.io/tags/%E8%BA%AB%E4%BB%BD%E9%89%B4%E5%88%AB/"},{"name":"来日可期","slug":"来日可期","permalink":"https://zofoa.github.io/tags/%E6%9D%A5%E6%97%A5%E5%8F%AF%E6%9C%9F/"},{"name":"CTF","slug":"CTF","permalink":"https://zofoa.github.io/tags/CTF/"},{"name":"内存取证","slug":"内存取证","permalink":"https://zofoa.github.io/tags/%E5%86%85%E5%AD%98%E5%8F%96%E8%AF%81/"}]}